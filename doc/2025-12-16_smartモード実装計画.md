# smartモード実装計画

## 概要

既存mockがあれば返し、なければproxy&recordする「smartモード」を追加する。
開発中に無駄なAPI接続を防ぎながら、新しいエンドポイントは自動で記録する。

## 背景・目的

- proxy/recordモードで既存mockがあるのに気づかず実サーバーに接続し続ける問題を解決
- API接続回数の削減（レート制限、コスト対策）
- 開発効率の向上（意識せずに最適な動作）

## smartモード仕様

### 基本動作フロー

```
リクエスト受信
    ↓
パターン選択済み？ ─No→ エラー400
    ↓ Yes
既存mockを検索（storage.findMatchingFile）
    ↓
mockあり？ ─Yes→ mockを返す（実サーバー接続なし）
    ↓ No
実サーバーにproxy & record
    ↓
レスポンスを返す
```

### モード一覧（変更後）

| モード | 動作 | 用途 |
|--------|------|------|
| `proxy` | 常に実サーバーに転送 | 本番同等の動作確認 |
| `record` | 常に実サーバーに転送＆記録 | mockデータ作成 |
| `mock` | 常にmockを返す（fallback設定あり） | オフラインテスト |
| **`smart`** | mockあり→mock、なし→proxy&record | **通常開発（推奨）** |

### 詳細仕様

- パターン必須（未選択時は400エラー）
- マッチング: 既存の`storage.findMatchingFile`を使用
- ログ出力:
  - mockヒット時: `GET /users/1 → smart → mock → users_001.json (200)`
  - record時: `GET /users/2 → smart → record → saved users_002.json (200, 1.2KB)`
- SSEイベント: record時のみ発行（`file_created` / `file_updated`）
- `mockFallback`設定の影響を受けない

---

## Phase 1: 型定義・コア実装

### 1-1. shared/types/mode.ts

**目的**: Mode型に`"smart"`を追加

**現在のコード**:
```typescript
export const ModeSchema = z.enum(["proxy", "record", "mock"]);
export type Mode = z.infer<typeof ModeSchema>;
```

**変更後**:
```typescript
export const ModeSchema = z.enum(["proxy", "record", "mock", "smart"]);
export type Mode = z.infer<typeof ModeSchema>;
```

**影響**: この変更により、Mode型を使用しているすべての箇所で`"smart"`が有効な値として認識される

---

### 1-2. server/handlers/smart.ts（新規作成）

**目的**: smartモードのリクエストハンドラーを実装

**ファイル内容**:
```typescript
import type { Context } from "hono";
import { logger } from "../core/logger.js";
import type { MatchResult } from "../core/matcher.js";
import { parseQueryParams, parseRequestBody } from "../core/request-utils.js";
import { state } from "../core/state.js";
import { storage } from "../core/storage.js";
import { handleRecord } from "./recorder.js";

/**
 * Smart mode handler
 * Return mock if exists, otherwise proxy & record
 */
export async function handleSmart(c: Context, match: MatchResult): Promise<Response> {
  const method = c.req.method;
  const url = new URL(c.req.url);
  const path = url.pathname;
  const pattern = state.getPattern();

  // 1. パターン必須チェック
  if (!pattern) {
    logger.warn(`${method} ${path} → no pattern selected`);
    return c.json({
      error: "No pattern selected",
      message: "Please select a pattern first",
    }, 400);
  }

  // 2. クエリパラメータ・ボディ取得
  const queryParams = parseQueryParams(url);
  const requestBody = await parseRequestBody(method, () => c.req.text());

  // 3. 既存mockを検索
  const result = await storage.findMatchingFile(
    pattern,
    method,
    match.matchedRoute,
    match.pathParams,
    queryParams,
    requestBody,
  );

  // 4. mockがあれば返す
  if (result) {
    logger.info(`${method} ${path} → smart → mock → ${result.filePath} (${result.fileData.response.status})`);

    const status = result.fileData.response.status;
    if (status === 304 || status === 204) {
      return c.body(null, status as never);
    }
    return c.json(result.fileData.response.body as object, status as never);
  }

  // 5. mockがなければrecord
  logger.info(`${method} ${path} → smart → record`);
  return handleRecord(c, match);
}
```

**依存関係**:
- `handleRecord`を再利用（recordモードと同じ処理）
- `storage.findMatchingFile`を再利用（mockモードと同じ検索ロジック）

---

### 1-3. server/handlers/handler.ts

**目的**: メインハンドラーのswitch文にsmartモードを追加

**現在のコード（L38-51）**:
```typescript
switch (mode) {
  case "proxy":
    return handleProxy(c, match.apiConfig);

  case "record":
    return handleRecord(c, match);

  case "mock":
    return handleMock(c, match, config);

  default:
    logger.error(`Unknown mode: ${mode}`);
    return c.json({ error: "Unknown mode" }, 500);
}
```

**変更後**:
```typescript
switch (mode) {
  case "proxy":
    return handleProxy(c, match.apiConfig);

  case "record":
    return handleRecord(c, match);

  case "mock":
    return handleMock(c, match, config);

  case "smart":
    return handleSmart(c, match);

  default:
    logger.error(`Unknown mode: ${mode}`);
    return c.json({ error: "Unknown mode" }, 500);
}
```

**追加import**:
```typescript
import { handleSmart } from "./smart.js";
```

---

### 1-4. server/handlers/control-api.ts

**目的**: モード変更APIのバリデーションにsmartを追加

**現在のコード（L59-62）**:
```typescript
const validModes = ["proxy", "record", "mock"];
if (!validModes.includes(mode)) {
  return c.json({ error: "Invalid mode", validModes }, 400);
}
```

**変更後**:
```typescript
const validModes = ["proxy", "record", "mock", "smart"];
if (!validModes.includes(mode)) {
  return c.json({ error: "Invalid mode", validModes }, 400);
}
```

---

## Phase 2: サーバーテスト

### 2-1. server/handlers/smart.test.ts（新規作成）

**目的**: smartモードハンドラーのユニットテスト

**テストケース**:

```typescript
import fs from "node:fs/promises";
import path from "node:path";
import { Hono } from "hono";
import { afterEach, beforeEach, describe, expect, it } from "vitest";
import { state } from "../core/state.js";
import { storage } from "../core/storage.js";
import type { SnaperroConfig } from "../types/config.js";
import { createHandler } from "./handler.js";

const TEST_PATTERN = "__test_smart__";
const BASE_DIR = ".snaperro/files";

const testConfig: SnaperroConfig = {
  port: 3333,
  filesDir: ".snaperro/files",
  mockFallback: "404",
  apis: {
    testApi: {
      name: "Test API",
      target: "https://jsonplaceholder.typicode.com",
      routes: ["/users", "/users/:id"],
    },
  },
};

describe("handleSmart", () => {
  let app: Hono;

  beforeEach(async () => {
    state.reset();
    await state.setMode("smart");
    await storage.createPattern(TEST_PATTERN);

    app = new Hono();
    const handler = createHandler(testConfig);
    app.all("*", handler);
  });

  afterEach(async () => {
    try {
      await fs.rm(path.join(BASE_DIR, TEST_PATTERN), { recursive: true, force: true });
    } catch {
      // ignore
    }
  });

  describe("パターン未選択", () => {
    it("パターン未選択時は400エラーを返す", async () => {
      // パターンを未選択状態にする
      await state.setPattern(null);

      const res = await app.request("/users");
      const body = (await res.json()) as { error: string };

      expect(res.status).toBe(400);
      expect(body.error).toBe("No pattern selected");
    });
  });

  describe("mockがある場合", () => {
    it("既存mockを返す（実サーバーにアクセスしない）", async () => {
      await state.setPattern(TEST_PATTERN);

      // mockファイルを作成
      const mockData = {
        endpoint: "/users",
        method: "GET",
        request: { pathParams: {}, queryParams: {}, headers: {}, body: null },
        response: { status: 200, headers: {}, body: { id: 1, name: "Test User" } },
      };
      await fs.writeFile(
        path.join(BASE_DIR, TEST_PATTERN, "users_001.json"),
        JSON.stringify(mockData, null, 2)
      );

      const res = await app.request("/users");
      const body = (await res.json()) as { id: number; name: string };

      expect(res.status).toBe(200);
      expect(body.name).toBe("Test User");
    });
  });

  describe("mockがない場合", () => {
    it("実サーバーにproxy&recordする", async () => {
      await state.setPattern(TEST_PATTERN);

      // mockファイルなし → proxy&record
      const res = await app.request("/users");

      // 実サーバーに接続できない環境では502になる可能性あり
      // 接続できる場合は200でファイルが作成される
      expect([200, 502]).toContain(res.status);
    });
  });
});
```

---

### 2-2. server/core/state.test.ts

**目的**: smartモードの状態管理テストを追加

**追加テストケース**:
```typescript
it("smartモードを設定できる", async () => {
  await state.setMode("smart");
  expect(state.getMode()).toBe("smart");
});
```

**挿入位置**: `describe("mode")` ブロック内（L34-40付近）

---

### 2-3. server/handlers/handler.test.ts

**目的**: smartモードのルーティングテストを追加

**追加テストケース**:
```typescript
describe("Smartモード", () => {
  it("パターン未設定の場合は400エラーを返す", async () => {
    await state.setMode("smart");
    // patternはnullのまま

    const res = await app.request("/api/users");
    const body = (await res.json()) as { error: string };

    expect(res.status).toBe(400);
    expect(body.error).toBe("No pattern selected");
  });
});
```

**挿入位置**: `describe("Mockモード")` ブロックの後（L83付近）

---

### 2-4. server/handlers/control-api.test.ts

**目的**: validModesにsmartが含まれることを確認

**変更箇所（L129）**:
```typescript
// 現在
expect(body.validModes).toEqual(["proxy", "record", "mock"]);

// 変更後
expect(body.validModes).toEqual(["proxy", "record", "mock", "smart"]);
```

---

## Phase 3: クライアント実装

### 3-1. client/src/components/TopBar.tsx

**目的**: smartモードのボタンを追加

**現在のコード（L13-17）**:
```typescript
const modes: { value: Mode; label: string; icon: string }[] = [
  { value: "proxy", label: "Proxy", icon: "→" },
  { value: "record", label: "Record", icon: "●" },
  { value: "mock", label: "Mock", icon: "◆" },
];
```

**変更後**:
```typescript
const modes: { value: Mode; label: string; icon: string }[] = [
  { value: "proxy", label: "Proxy", icon: "→" },
  { value: "record", label: "Record", icon: "●" },
  { value: "mock", label: "Mock", icon: "◆" },
  { value: "smart", label: "Smart", icon: "⚡" },
];
```

**handleModeClick修正（L24-33）**:
smartモードもrecordモードと同様にパターン選択が必要なので、条件を更新:

```typescript
const handleModeClick = (targetMode: Mode) => {
  // record と smart はパターン選択が必要
  if ((targetMode === "record" || targetMode === "smart") && !currentPattern) {
    toaster.create({
      type: "warning",
      title: "No pattern selected",
      description: "Please select a pattern first.",
    });
    return;
  }
  onModeChange(targetMode);
};
```

**スタイル追加（L66-71付近）**:
smartモード用の色を追加:

```typescript
const getColor = () => {
  if (isRecording) return "recording";
  if (isMock) return "mock";
  if (value === "smart" && isActive) return "accent";  // または新色
  return "accent";
};
```

---

### 3-2. demo/src/components/ModeSelector.tsx

**目的**: デモ画面にsmartモードボタンを追加

**現在のコード（L3）**:
```typescript
export type Mode = "proxy" | "record" | "mock";
```

**変更後**:
```typescript
export type Mode = "proxy" | "record" | "mock" | "smart";
```

**modeConfig追加（L11-27）**:
```typescript
const modeConfig: Record<Mode, { label: string; icon: string; description: string }> = {
  proxy: {
    label: "Proxy",
    icon: "→",
    description: "Pass through to real API",
  },
  record: {
    label: "Record",
    icon: "●",
    description: "Save responses to files",
  },
  mock: {
    label: "Mock",
    icon: "◆",
    description: "Return saved responses",
  },
  smart: {
    label: "Smart",
    icon: "⚡",
    description: "Return mock if exists, otherwise record",
  },
};
```

---

## Phase 4: ドキュメント更新

### 4-1. README.md

**変更箇所**:

1. **Features セクション（L17）**:
   - `- **3 Modes**:` → `- **4 Modes**:`

2. **モード一覧表（L219-224）**:
```markdown
| Mode | Real API | Save JSON | Returns |
|------|----------|-----------|---------|
| **Proxy** | Access | No | Real response |
| **Record** | Access | Yes | Real response |
| **Mock** | No access | No | Saved JSON |
| **Smart** | Conditional | Conditional | Mock or Real |
```

3. **Smartモードセクション追加（L262付近、Mock Fallback Behaviorの前）**:
```markdown
#### Smart Mode

Automatically returns mock data if it exists, otherwise proxies to the real server and records the response.

```
Request → snaperro → Search mock files
                ↓
         Found? → Yes → Return mock (no API access)
                ↓ No
         Proxy to real API & Record
                ↓
         Return response
```

This is the recommended mode for daily development:
- Prevents unnecessary API calls when mock data already exists
- Automatically records new endpoints
- Reduces API rate limit concerns
```

---

### 4-2. README_ja.md

**変更箇所**:

1. **特徴セクション（L17）**:
   - `- **3つのモード**:` → `- **4つのモード**:`

2. **モード一覧表（L219-224）**:
```markdown
| モード | 本物のAPI | JSON保存 | 返すもの |
|-------|----------|---------|---------|
| **Proxy** | アクセスする | しない | 本物のレスポンス |
| **Record** | アクセスする | する | 本物のレスポンス |
| **Mock** | アクセスしない | しない | 保存済みJSON |
| **Smart** | 条件付き | 条件付き | mockまたは本物 |
```

3. **Smartモードセクション追加（L262付近）**:
```markdown
#### Smartモード

既存のmockデータがあれば自動的にそれを返し、なければ実サーバーにプロキシしてレスポンスを記録します。

```
リクエスト → snaperro → mockファイルを検索
                ↓
         見つかった？ → Yes → mockを返す（API接続なし）
                ↓ No
         実際のAPIにプロキシ & 記録
                ↓
         レスポンスを返す
```

日常の開発ではこのモードを推奨します：
- mockデータが既にある場合は無駄なAPI接続を防ぐ
- 新しいエンドポイントは自動的に記録される
- APIレート制限の心配を軽減
```

---

### 4-3. snaperro.config.ts

**目的**: コメントでsmartモードの説明を追記

**変更後**:
```typescript
import { defineConfig } from "snaperro";

export default defineConfig({
  port: 3333,
  filesDir: ".snaperro/files",
  mockFallback: "404",

  // Available modes:
  // - proxy: Always forward to real API
  // - record: Forward to real API and save response
  // - mock: Return saved mock data
  // - smart: Return mock if exists, otherwise proxy & record (recommended)

  apis: {
    // JSON Placeholder API（サンプル）
    jsonPlaceholder: {
      name: "JSON Placeholder",
      target: "https://jsonplaceholder.typicode.com",
      routes: ["/users", "/users/:id", "/posts", "/posts/:id", "/posts/:id/comments", "/comments"],
      maskRequestHeaders: ["connection"],
    },
  },
});
```

---

## Phase 5: 最終確認

### 5-1. 型チェック

```bash
pnpm type-check        # サーバー
pnpm type-check:client # クライアント
pnpm type-check:demo   # デモ
```

**確認ポイント**:
- Mode型の変更がすべての箇所に伝播しているか
- handleSmartのインポートが正しいか

---

### 5-2. フォーマット

```bash
pnpm format
```

---

### 5-3. テスト実行

```bash
pnpm test
```

**確認ポイント**:
- 新規テスト（smart.test.ts）がパスするか
- 既存テストの修正箇所がパスするか
- control-api.test.tsのvalidModes更新

---

### 5-4. 手動確認

1. `npx . start` でサーバー起動
2. GUIでsmartモードに切り替え可能か確認
3. smartモードでの動作確認:
   - mockがある場合: mockが返される（ログ: `→ smart → mock →`）
   - mockがない場合: recordされる（ログ: `→ smart → record →`）

---

## チェックリスト

### Phase 1: 型定義・コア実装
- [ ] `shared/types/mode.ts` - "smart"追加
- [ ] `server/handlers/smart.ts` - 新規作成
- [ ] `server/handlers/handler.ts` - switch文更新、import追加
- [ ] `server/handlers/control-api.ts` - validModes更新

### Phase 2: サーバーテスト
- [ ] `server/handlers/smart.test.ts` - 新規作成
- [ ] `server/core/state.test.ts` - smartモードテスト追加
- [ ] `server/handlers/handler.test.ts` - Smartモードテスト追加
- [ ] `server/handlers/control-api.test.ts` - validModes期待値更新

### Phase 3: クライアント実装
- [ ] `client/src/components/TopBar.tsx` - smartボタン追加
- [ ] `demo/src/components/ModeSelector.tsx` - smartボタン追加

### Phase 4: ドキュメント更新
- [ ] `README.md` - 4モードに更新、Smartモード説明追加
- [ ] `README_ja.md` - 4モードに更新、Smartモード説明追加
- [ ] `snaperro.config.ts` - モード説明コメント追記

### Phase 5: 最終確認
- [ ] `pnpm type-check` - 成功
- [ ] `pnpm type-check:client` - 成功
- [ ] `pnpm type-check:demo` - 成功
- [ ] `pnpm format` - 成功
- [ ] `pnpm test` - 成功
- [ ] 手動動作確認 - 完了
