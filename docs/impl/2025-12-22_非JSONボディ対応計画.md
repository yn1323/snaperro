# 非JSONボディ対応計画

## 概要

Record/Proxyモードで`application/x-www-form-urlencoded`などの非JSONボディを正しく転送できるようにする。

## スコープ

- **対応**: `application/x-www-form-urlencoded`, `text/plain`, その他非JSONボディ
- **非対応**: `multipart/form-data`（ファイルアップロード）

## 問題

`application/x-www-form-urlencoded`リクエスト時に以下の問題が発生:
1. **Content-Typeヘッダーが欠落** - ターゲットAPIに転送されない
2. **リクエストボディが不正** - `JSON.stringify`により二重エスケープ
3. **502 Bad Gateway** - 上記の結果としてAPIがエラー

## 原因分析

### recorder.ts - ボディ処理 (Line 51)

```typescript
// Line 42: リクエストボディをパース
const requestBody = await parseRequestBody(method, () => c.req.text());

// Line 51: 常にJSON.stringify
body: requestBody ? JSON.stringify(requestBody) : undefined,
```

`x-www-form-urlencoded`ボディ `"foo=bar&baz=qux"` の場合:
- `parseRequestBody`: JSON.parseが失敗 → テキスト `"foo=bar&baz=qux"` を返す
- `JSON.stringify("foo=bar&baz=qux")` → `"\"foo=bar&baz=qux\""` (不正)

### proxy.ts（正常動作）との比較

```typescript
// Line 24: parseJson = false
const body = (await parseRequestBody(method, () => c.req.text(), false)) as string | null;

// Line 34: そのまま渡す
body,
```

## 解決策

### アプローチ: Content-Typeに基づくボディ処理

Content-Typeに基づいてボディの処理を分岐する:
- `application/json`: JSONパース + stringify (現状維持)
- その他: テキストをそのまま転送

## 修正対象ファイル

1. **server/handlers/recorder.ts** - ボディ処理の修正
2. **server/core/request-utils.ts** - Content-Type判定ヘルパー追加

## 実装手順

### Step 1: request-utils.ts - ヘルパー関数追加

```typescript
export function isJsonContentType(headers: Headers): boolean {
  const contentType = headers.get("content-type") || "";
  return contentType.includes("application/json");
}
```

### Step 2: recorder.ts - ボディ処理修正

```typescript
// Before fetch: Content-Typeに基づいてボディを準備
const isJson = isJsonContentType(c.req.raw.headers);
const requestBodyForFetch = requestBody
  ? (isJson ? JSON.stringify(requestBody) : requestBody)
  : undefined;

// fetch call
const response = await fetch(targetUrl, {
  method,
  headers,
  body: requestBodyForFetch,
  dispatcher: getProxyAgent(),
});
```

### Step 3: 記録データ - 元の形式を保持

記録用データには元のボディ形式を保持:
- JSONの場合: パース済みオブジェクト
- 非JSONの場合: 生テキスト（`"foo=bar&baz=qux"`）

**Note**: smart.tsは`handleRecord`に委譲しているので、recorder.tsの修正で対応可能。

### Step 4: テスト追加

#### request-utils.test.ts
- `isJsonContentType` 関数のテスト
  - `application/json` → true
  - `application/json; charset=utf-8` → true
  - `application/x-www-form-urlencoded` → false
  - `text/plain` → false
  - ヘッダーなし → false

#### recorder.test.ts
- `x-www-form-urlencoded` ボディの転送テスト
  - ボディがそのまま転送される（`JSON.stringify`されない）
  - Content-Type ヘッダーが正しく転送される
  - 記録データにテキストボディがそのまま保存される

#### proxy.test.ts
- `x-www-form-urlencoded` ボディの転送確認テスト
  - 現状動くはずだが、確認のためテスト追加

#### mocker.test.ts
- 非JSONボディで記録されたデータのマッチングテスト
  - テキストボディでのマッチング確認

## テスト計画

1. `pnpm type-check` - 型チェック
2. `pnpm test` - 既存テストが壊れていないか確認
3. 手動テスト: `x-www-form-urlencoded`リクエストの動作確認
